-------------------
-- Semantic Coll --
-------------------

-- This representation exhibits the semantically correct behavior for
-- all operations, assuming they have an implementation in terms of
-- the fundamental operations. However, the implementations will
-- typically be *very* slow, and is basically never the correct choice
-- in an actual program.

repr SemanticColl {UColl _ ?x = Rope ?x}

letimpl[0.0] empty : !SemanticColl = ropeEmpty
letimpl[3.0] append_op : !SemanticColl -> _ -> !SemanticColl = ropeAppend
letimpl[3.0] prepend_op : _ -> !SemanticColl -> !SemanticColl = ropePrepend
-- TODO(vipa, 2023-10-20): Replace the '2.0' with `logf n`
-- TODO(vipa, 2023-10-22): This requires out-of-order op access, so it'll have to wait for the moment
-- letimpl[addf (addf 8.0 (mulf 12.0 n)) (mulf n 2.0)] foldl
--   : all o. all p. _ -> _ -> Coll /(o, p) _ -> _
--   = lam f. lam acc. lam coll.
--     let order : Phantom o = Phantom {} in
--     let select : Phantom p = Phantom {} in
--     let len = ropeLength coll in

--     let idxes = orderSem order coll in
--     let ordered = ropeQuickSortBy (lam a. lam b. subi a.0 b.0) (zip idxes coll) in -- n log n
--     let ordered = map (lam x. x.1) ordered in -- n
--     -- idxes could theoretically be shorter than coll, handle that
--     let ordered = concat ordered (drop (length idxes) coll) in -- 3 + 2 + 3

--     recursive let work = lam acc. lam idx.
--       if eqi idx len then -- 1
--         let pre = take idx ordered in -- 3
--         let elem = get ordered idx in -- 2
--         let post = drop (addi idx 1) ordered in -- 3 + 1
--         let acc =
--           if @n selectSem select pre elem post
--           then f acc elem -- 1
--           else acc in -- 0
--         work acc (addi idx 1) -- 1
--       else acc -- 0
--     in work acc 0 -- 12n total

-----------
-- Ropes --
-----------

repr Rope {UColl _ ?x = Rope ?x}

-- We take into account that the built-in ropes have one extra layer
-- of indirection, so basically all operations must unwrap and rewrap
-- that, i.e., +1 cost for each rope input/output.

letimpl[0.0] empty : !Rope = ropeEmpty
letimpl[3.0] append_op : !Rope -> _ -> !Rope = ropeAppend
letimpl[3.0] prepend_op : _ -> !Rope -> !Rope = ropePrepend
letimpl[addf n 2.0] foldl : _ -> _ -> !Rope -> _ = ropeFoldl
letimpl[addf n 2.0] foldr : _ -> _ -> !Rope -> _ = ropeFoldr
letimpl[2.0] length : !Rope -> _ = ropeLength

letimpl[0.0] collFromSeq : _ -> !Rope = lam x. x
letimpl[0.0] q : _ -> !Rope = lam x. x
letimpl[0.0] seqFromColl : !Rope -> _ = lam x. x

letimpl[4.0] concat_op : !Rope -> !Rope -> !Rope = ropeConcat

---------------
-- Cons-list --
---------------

repr Cons {UColl _ ?x = ConsList ?x}

letimpl[0.0] empty : !Cons = consEmpty
letimpl[addf n 1.0] append_op : !Cons -> _ -> !Cons = consAppend
letimpl[1.0] prepend_op : _ -> !Cons -> !Cons = consPrepend
letimpl[n] foldl : _ -> _ -> !Cons -> _ = consFoldl
letimpl[n] foldr : _ -> _ -> !Cons -> _ = consFoldr

letimpl[1.0] splitFirst_op : !Cons -> _ /(_, !Cons) = consUncons

--------------------------------------
-- Defaults/general implementations --
--------------------------------------

letimpl[3.0] q = lam xs. ropeFoldr prepend_op (@1 empty) xs
letimpl[3.0] q = lam xs. ropeFoldl append_op (@1 empty) xs

letimpl[addf n 2.0] collFromSeq = lam xs. ropeFoldr (@n prepend_op) (@1 empty) xs
letimpl[addf n 2.0] collFromSeq = lam xs. ropeFoldl (@n append_op) (@1 empty) xs
letimpl[mulf n 3.0] seqFromColl = lam xs. foldl ropeAppend ropeEmpty xs
letimpl[mulf n 3.0] seqFromColl = lam xs. foldr ropePrepend ropeEmpty xs

letimpl[0.0] view : all p. Coll p _ -> Coll p _ = lam xs. xs
letimpl[1.0] view = lam xs. foldl (@n append_op) empty xs
letimpl[1.0] view = lam xs. foldr (@n prepend_op) empty xs

letimpl[1.0] singleton = lam x. append_op empty x
letimpl[1.0] singleton = lam x. prepend_op x empty

letimpl[1.0] concat_op : all p. Coll p _ -> _ -> Coll p _ = lam a. lam b. foldl (@n append_op) a b
letimpl[1.0] concat_op : all p. _ -> Coll p _ -> Coll p _ = lam a. lam b. foldr (@n prepend_op) b a

-- foldl1
-- foldr1
-- unfoldl
-- unfoldr
-- foldl2_op

letimpl[1.0] map_op = lam f. lam xs. foldl (lam acc. lam x. @n append_op acc (f x)) empty xs
letimpl[1.0] map_op = lam f. lam xs. foldr (lam x. lam acc. @n prepend_op (f x) acc) empty xs

letimpl[1.0] map2_op = lam f. lam as. lam bs. foldl2_op (lam acc. lam l. lam r. @n append_op acc (f l r)) empty as bs
